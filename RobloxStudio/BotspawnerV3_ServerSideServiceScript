-- BOT SPAWNER V3 - Script Version
-- Place this in: ServerScriptService
-- This automatically spawns bots when the game runs
-- Automatically stops when exiting test mode (Scripts stop naturally)

local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

-- Top 10 popular names starting with R (for Red Team)
local RED_TEAM_NAMES = {
	"Robert", "Richard", "Ryan", "Raymond", "Ronald",
	"Russell", "Roy", "Roger", "Ralph", "Randy"
}

-- Top 10 popular names starting with B (for Blue Team)
local BLUE_TEAM_NAMES = {
	"Benjamin", "Brandon", "Brian", "Blake", "Bradley",
	"Brett", "Bryce", "Bruce", "Brent", "Brody"
}

-- Track bot names and spawn info for respawning
local botSpawnInfo = {} -- [bot] = {name, teamName, enemySpawnPos, teamColor}

-- print("=== Smart Bot Spawner (Script Version) ===")
-- print("Bot spawning will start automatically...")

-- Function to find ground position using raycasting (works with terrain and parts)
local function findGroundPosition(startPosition)
	-- Raycast downward from a fixed high point to find terrain or parts
	-- Use a high Y (500) to avoid hitting ceilings, cast down far enough to reach ground
	local rayOrigin = Vector3.new(startPosition.X, 500, startPosition.Z) -- Start at fixed high point
	local rayDirection = Vector3.new(0, -1000, 0) -- Cast down 1000 studs to ensure we reach ground
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.FilterDescendantsInstances = {} -- Will filter out bots and players

	-- Filter out bots and players from raycast
	local filterList = {}
	for _, obj in ipairs(workspace:GetChildren()) do
		if obj:IsA("Model") and (obj.Name:find("_Bot_") or obj:FindFirstChildOfClass("Humanoid")) then
			table.insert(filterList, obj)
		end
	end
	raycastParams.FilterDescendantsInstances = filterList

	local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

	if raycastResult then
		-- Only use the result if it's at a reasonable height (below 200 studs)
		-- This avoids spawning on ceilings or very high structures
		if raycastResult.Position.Y < 200 then
			-- Found terrain or ground part - spawn 2 studs above it
			return Vector3.new(startPosition.X, raycastResult.Position.Y + 2, startPosition.Z)
		end
	end

	-- Fallback: try baseplate
	local baseplate = workspace:FindFirstChild("Baseplate")
	if baseplate and baseplate:IsA("Part") then
		local groundY = baseplate.Position.Y + (baseplate.Size.Y / 2)
		return Vector3.new(startPosition.X, groundY + 2, startPosition.Z)
	else
		-- Last resort: use spawn position Y if reasonable, otherwise 10
		local fallbackY = startPosition.Y
		if fallbackY > 200 then
			fallbackY = 10  -- If spawn is too high, use safe default
		end
		return Vector3.new(startPosition.X, fallbackY + 2, startPosition.Z)
	end
end

-- Simple bot creation (matching existing bot structure)
local function createSimpleBot(position, teamColor, teamName, enemySpawnPos, botName)
	-- DIAGNOSTIC: Find and log spawn location details (recursive search)
	local function findSpawnLocationRecursive(parent, teamName)
		for _, obj in ipairs(parent:GetChildren()) do
			if obj:IsA("SpawnLocation") then
				if teamName == "Red Team" or teamName:find("Red") then
					if obj.Name:find("Red") or obj.TeamColor == BrickColor.new("Bright red") then
						return obj
					end
				else
					if obj.Name:find("Blue") or obj.TeamColor == BrickColor.new("Bright blue") then
						return obj
					end
				end
			elseif obj:IsA("Folder") or obj:IsA("Model") then
				local found = findSpawnLocationRecursive(obj, teamName)
				if found then return found end
			end
		end
		return nil
	end

	local spawnLocation = nil
	if teamName == "Red Team" or teamName:find("Red") then
		spawnLocation = workspace:FindFirstChild("RedSpawnLocation")
		if not spawnLocation then
			spawnLocation = findSpawnLocationRecursive(workspace, teamName)
		end
	else
		spawnLocation = workspace:FindFirstChild("BlueSpawnLocation")
		if not spawnLocation then
			spawnLocation = findSpawnLocationRecursive(workspace, teamName)
		end
	end

	-- DIAGNOSTIC: Print spawn location info
	if spawnLocation then
		print("  ðŸ” DIAGNOSTIC - Spawn Location for " .. teamName .. ":")
		print("    Name: " .. spawnLocation.Name)
		print("    Position: " .. tostring(spawnLocation.Position))
		print("    Anchored: " .. tostring(spawnLocation.Anchored))
		print("    CanCollide: " .. tostring(spawnLocation.CanCollide))
		print("    Enabled: " .. tostring(spawnLocation.Enabled))
		print("    TeamColor: " .. tostring(spawnLocation.TeamColor))

		-- Get terrain height at spawn location
		local terrainHeight = nil
		local rayOrigin = Vector3.new(spawnLocation.Position.X, 500, spawnLocation.Position.Z)
		local rayDirection = Vector3.new(0, -1000, 0)
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
		raycastParams.FilterDescendantsInstances = {}
		local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
		if raycastResult then
			terrainHeight = raycastResult.Position.Y
			print("    Terrain Height (via raycast): " .. string.format("%.2f", terrainHeight))
		else
			-- Fallback to baseplate
			local baseplate = workspace:FindFirstChild("Baseplate")
			if baseplate then
				terrainHeight = baseplate.Position.Y + (baseplate.Size.Y / 2)
				print("    Terrain Height (baseplate fallback): " .. string.format("%.2f", terrainHeight))
			end
		end

		if terrainHeight then
			local heightAboveTerrain = spawnLocation.Position.Y - terrainHeight
			print("    Height Above Terrain: " .. string.format("%.2f", heightAboveTerrain) .. " studs")
		end
	else
		print("  âš  DIAGNOSTIC - No spawn location found for " .. teamName)
		print("    Using provided position: " .. tostring(position))
	end

	-- Use actual spawn location position if found, otherwise use provided position
	local actualSpawnPos = position
	if spawnLocation then
		actualSpawnPos = spawnLocation.Position
		print("  ðŸ” DIAGNOSTIC - Using spawn location position: " .. tostring(actualSpawnPos))
	else
		print("  ðŸ” DIAGNOSTIC - Using provided position: " .. tostring(actualSpawnPos))
	end

	-- Find actual terrain height at spawn location using raycast
	-- Use the SAME simple raycast that works in diagnostics (finds terrain at 143)
	local function findTerrainHeight(x, z)
		-- Use the exact same raycast as the diagnostic (which works correctly)
		local rayOrigin = Vector3.new(x, 500, z)
		local rayDirection = Vector3.new(0, -1000, 0)
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
		raycastParams.FilterDescendantsInstances = {} -- Empty filter list like diagnostic

		local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

		if raycastResult then
			local hitPart = raycastResult.Instance
			-- Prioritize terrain hits (this is what the diagnostic finds)
			if hitPart and (hitPart.Name == "Terrain" or hitPart:IsDescendantOf(workspace.Terrain)) then
				if raycastResult.Position.Y > 10 and raycastResult.Position.Y < 200 then
					return raycastResult.Position.Y
				end
				-- Accept any hit that's in reasonable range (terrain should be ~143)
			elseif raycastResult.Position.Y > 30 and raycastResult.Position.Y < 200 then
				-- Only accept if it's not a spawn location
				if not hitPart:IsA("SpawnLocation") then
					return raycastResult.Position.Y
				end
			end
		end

		-- Fallback: Use terrain height estimate (terrain is typically around 140-143)
		return 140
	end

	local terrainHeight = findTerrainHeight(actualSpawnPos.X, actualSpawnPos.Z)

	-- DIAGNOSTIC: Verify terrain height calculation
	print("  ðŸ” DIAGNOSTIC - Terrain Height Calculation:")
	print("    Calculated terrainHeight: " .. tostring(terrainHeight))
	print("    Spawn location Y: " .. tostring(actualSpawnPos.Y))

	-- Spawn at terrain height + 2 studs (small offset above ground)
	-- Ensure we use the calculated terrain height, not the spawn location's Y
	local spawnPos = Vector3.new(actualSpawnPos.X, terrainHeight + 2, actualSpawnPos.Z)

	-- DIAGNOSTIC: Print bot spawn position
	print("  ðŸ” DIAGNOSTIC - Bot Spawn Position:")
	print("    Final Spawn Position (Y+2): " .. tostring(spawnPos))
	print("    Expected Y should be: " .. tostring(terrainHeight + 2))

	-- Convert Color3 to BrickColor
	local brickColor
	if teamName == "Red Team" or teamName:find("Red") then
		brickColor = BrickColor.new("Bright red")
	elseif teamName == "Blue Team" or teamName:find("Blue") then
		brickColor = BrickColor.new("Bright blue")
	else
		-- Default to blue if team name doesn't match
		brickColor = BrickColor.new("Bright blue")
	end

	-- Assign a name if not provided (for respawning, name is provided)
	if not botName then
		-- Use R names for Red Team, B names for Blue Team
		if teamName == "Red Team" or teamName:find("Red") then
			botName = RED_TEAM_NAMES[math.random(1, #RED_TEAM_NAMES)]
		else
			botName = BLUE_TEAM_NAMES[math.random(1, #BLUE_TEAM_NAMES)]
		end
	end

	local bot = Instance.new("Model")
	bot.Name = botName -- Use real name instead of random number

	-- HumanoidRootPart (twice as tall as standard player)
	local rootPart = Instance.new("Part")
	rootPart.Name = "HumanoidRootPart"
	rootPart.Size = Vector3.new(4, 4, 2) -- Twice as tall (was 2, 2, 1)
	rootPart.Position = spawnPos
	rootPart.Anchored = false  -- Unanchored so bot can fall with gravity
	rootPart.CanCollide = true
	rootPart.BrickColor = brickColor
	rootPart.Material = Enum.Material.SmoothPlastic
	rootPart.Transparency = 0 -- Ensure fully visible
	rootPart.Parent = bot

	-- Humanoid (must be created after parts)
	local humanoid = Instance.new("Humanoid")
	humanoid.WalkSpeed = 16
	humanoid.MaxHealth = 100
	humanoid.Health = 100
	humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer -- Show health bar
	humanoid.UseJumpPower = true
	humanoid.JumpPower = 50
	humanoid.Parent = bot

	-- Wait a frame to ensure everything is set up before enabling physics
	task.wait(0)

	-- Ensure Humanoid respects physics and gravity
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, true)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)

	-- Ensure rootPart is unanchored for gravity
	rootPart.Anchored = false

	-- Store team info in a StringValue (bots can't be assigned to Teams like players)
	local teamValue = Instance.new("StringValue")
	teamValue.Name = "Team"
	teamValue.Value = teamName
	teamValue.Parent = bot

	-- Store bot's real name
	local nameValue = Instance.new("StringValue")
	nameValue.Name = "BotName"
	nameValue.Value = botName
	nameValue.Parent = bot

	-- Store spawn info for respawning
	botSpawnInfo[bot] = {
		name = botName,
		teamName = teamName,
		enemySpawnPos = enemySpawnPos,
		teamColor = teamColor,
		spawnPos = position -- Store original spawn position
	}

	-- Track bot death - bots fall down and disappear when dead
	humanoid.Died:Connect(function()
		-- Find the team by name and update its bot list (use pcall in case function isn't ready)
		pcall(function()
			for _, team in ipairs(Teams:GetTeams()) do
				if team.Name == teamName then
					if updateTeamBotList then
						updateTeamBotList(team)
					end
					break
				end
			end
		end)

		-- Unanchor the bot so it can fall down
		if rootPart then
			rootPart.Anchored = false
		end

		-- Also unanchor head and torso if they exist
		local head = bot:FindFirstChild("Head")
		if head then
			head.Anchored = false
		end
		local torso = bot:FindFirstChild("Torso")
		if torso then
			torso.Anchored = false
		end

		-- Wait a moment for the bot to fall, then destroy it
		local botToDestroy = bot -- Store reference to bot
		spawn(function()
			task.wait(3) -- Wait 3 seconds for bot to fall
			if botToDestroy and botToDestroy.Parent then
				botToDestroy:Destroy()
				print("  ðŸ’€ " .. botName .. " despawned after death")
			end
		end)
	end)

	-- Head (twice as tall, more visible)
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Size = Vector3.new(4, 2, 2) -- Twice as tall (was 2, 1, 1)
	head.BrickColor = BrickColor.new("New Yeller") -- Bright yellow head for visibility
	head.Material = Enum.Material.Neon -- Neon material to make it stand out
	head.CanCollide = false -- Head shouldn't collide (matching player behavior)
	head.Anchored = false -- Unanchored so it moves with the body
	head.Transparency = 0 -- Ensure fully visible
	head.Parent = bot

	-- Torso (twice as tall, for visual)
	local torso = Instance.new("Part")
	torso.Name = "Torso"
	torso.Size = Vector3.new(4, 4, 2) -- Twice as tall (was 2, 2, 1)
	torso.BrickColor = brickColor
	torso.Material = Enum.Material.SmoothPlastic
	torso.CanCollide = false
	torso.Anchored = false
	torso.Transparency = 0 -- Fully visible (was 0.3)
	torso.Parent = bot

	-- Set PrimaryPart (important for raycasting and model detection)
	bot.PrimaryPart = rootPart

	-- Parent bot to workspace (Humanoid needs to be in workspace to detect root part)
	bot.Parent = workspace

	-- Position head and torso after bot is in workspace (ensures proper CFrame calculations)
	-- Head positioned 3 studs above rootPart center (was 1.5, now 3 for double height)
	head.CFrame = rootPart.CFrame * CFrame.new(0, 3, 0)
	torso.CFrame = rootPart.CFrame

	-- Create Welds to attach head and torso to body (after positioning)
	local headWeld = Instance.new("WeldConstraint")
	headWeld.Part0 = rootPart
	headWeld.Part1 = head
	headWeld.Parent = rootPart

	local torsoWeld = Instance.new("WeldConstraint")
	torsoWeld.Part0 = rootPart
	torsoWeld.Part1 = torso
	torsoWeld.Parent = rootPart

	-- Create health bar BillboardGui AFTER head is created and positioned
	-- Attach to head so it's positioned right above the head with a small gap
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "HealthBar"
	billboardGui.Size = UDim2.new(0, 200, 0, 50)
	billboardGui.StudsOffset = Vector3.new(0, 1.5, 0) -- Small gap above head (head is 2 studs tall, so 1.5 puts it just above)
	billboardGui.AlwaysOnTop = true -- Always visible
	billboardGui.MaxDistance = math.huge -- No distance limit
	billboardGui.LightInfluence = 0 -- Disable lighting/shadow effects
	billboardGui.Adornee = head -- Attach to head
	billboardGui.Parent = head

	-- Background frame
	local bgFrame = Instance.new("Frame")
	bgFrame.Name = "Background"
	bgFrame.Size = UDim2.new(1, 0, 1, 0)
	bgFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	bgFrame.BackgroundTransparency = 0.3
	bgFrame.BorderSizePixel = 2
	bgFrame.BorderColor3 = Color3.new(1, 1, 1)
	bgFrame.Parent = billboardGui

	-- Health bar frame
	local healthBar = Instance.new("Frame")
	healthBar.Name = "HealthBar"
	healthBar.Size = UDim2.new(1, -4, 0.6, -4)
	healthBar.Position = UDim2.new(0, 2, 0, 2)
	healthBar.BackgroundColor3 = Color3.new(0, 1, 0) -- Green
	healthBar.BorderSizePixel = 0
	healthBar.Parent = bgFrame

	-- Name label
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, 0, 0, 20)
	nameLabel.Position = UDim2.new(0, 0, 0, 30)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = botName
	nameLabel.TextColor3 = Color3.new(1, 1, 1)
	nameLabel.TextSize = 14
	nameLabel.TextStrokeTransparency = 0.5
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.Parent = bgFrame

	-- Update health bar when health changes
	local function updateHealthBar()
		if humanoid and healthBar and nameLabel then
			local healthPercent = humanoid.Health / humanoid.MaxHealth

			-- If bot is dead, show all red and "dead" text
			if humanoid.Health <= 0 then
				healthBar.Size = UDim2.new(1, -4, 0.6, -4) -- Full width (all red)
				healthBar.BackgroundColor3 = Color3.new(1, 0, 0) -- Red
				nameLabel.Text = "dead" -- Show "dead" instead of name
			else
				-- Bot is alive - show normal health bar
				healthBar.Size = UDim2.new(healthPercent, -4, 0.6, -4)
				nameLabel.Text = botName -- Show bot's name

				-- Change color based on health
				if healthPercent > 0.6 then
					healthBar.BackgroundColor3 = Color3.new(0, 1, 0) -- Green
				elseif healthPercent > 0.3 then
					healthBar.BackgroundColor3 = Color3.new(1, 1, 0) -- Yellow
				else
					healthBar.BackgroundColor3 = Color3.new(1, 0, 0) -- Red
				end
			end
		end
	end

	-- Connect health changes
	humanoid.HealthChanged:Connect(updateHealthBar)
	updateHealthBar() -- Initial update

	-- Debug: Print bot creation info
	print("  âœ“ Created bot: " .. bot.Name .. " at position: " .. tostring(spawnPos))

	-- Track spawn time for movement protection (5 seconds)
	local spawnTime = tick()
	local SPAWN_PROTECTION_DURATION = 5 -- Seconds before bot can move

	-- Ensure Humanoid recognizes the Head part (for health bar display)
	-- Wait a frame to ensure everything is set up
	task.wait(0)
	if humanoid then
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, true)
	end

	-- AI variables
	local humanoidReady = false

	-- Helper function to find terrain height at a position (for target positioning)
	local function getTerrainHeight(x, z)
		-- Start raycast from a high fixed point (500) to ensure we hit terrain
		local rayOrigin = Vector3.new(x, 500, z)
		local rayDirection = Vector3.new(0, -1000, 0) -- Cast down 1000 studs
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

		-- Filter out all bots and players
		local filterList = {}
		for _, obj in ipairs(workspace:GetChildren()) do
			if obj:IsA("Model") and (obj.Name:find("_Bot_") or obj:FindFirstChildOfClass("Humanoid")) then
				table.insert(filterList, obj)
			end
		end
		raycastParams.FilterDescendantsInstances = filterList

		local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
		if raycastResult then
			-- Only use result if it's at a reasonable height (above -50, below 200)
			if raycastResult.Position.Y > -50 and raycastResult.Position.Y < 200 then
				return raycastResult.Position.Y
			end
		end

		-- Fallback to baseplate top
		local baseplate = workspace:FindFirstChild("Baseplate")
		if baseplate and baseplate:IsA("Part") then
			return baseplate.Position.Y + (baseplate.Size.Y / 2)
		end

		-- Last resort: return a safe default (baseplate level)
		return 0
	end

	-- Wait for Humanoid to detect HumanoidRootPart, then start AI
	spawn(function()
		-- Wait multiple frames to ensure Humanoid detects RootPart
		for i = 1, 3 do
			RunService.Heartbeat:Wait()
		end

		-- Force Humanoid to detect RootPart
		if not humanoid.RootPart then
			warn("âš  " .. bot.Name .. ": Humanoid.RootPart is nil! Trying to fix...")
			-- Try changing state to force detection
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			RunService.Heartbeat:Wait()
			humanoid:ChangeState(Enum.HumanoidStateType.Physics)
			RunService.Heartbeat:Wait()
		end

		if humanoid.RootPart then
			-- print("âœ“ " .. bot.Name .. ": Humanoid.RootPart detected")
			humanoidReady = true
		else
			warn("âŒ " .. bot.Name .. ": Humanoid.RootPart still nil after fixes!")
			humanoidReady = false
		end
	end)

	-- Simple AI: Move directly towards enemy spawn with stuck detection
	local lastMoveTime = 0
	local lastPosition = nil
	local lastPositionTime = 0

	-- Function to check for open air beneath bot
	-- Only triggers if bot is truly floating (not just on a slope)
	local function checkForOpenAir(botPosition)
		-- Raycast straight down from bot's position to check for ground
		local rayOrigin = Vector3.new(botPosition.X, botPosition.Y - 1, botPosition.Z) -- Start just below bot
		local rayDirection = Vector3.new(0, -15, 0) -- Cast down 15 studs (increased for better slope detection)
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

		-- Filter out the bot itself and other bots
		local filterList = {bot}
		for _, obj in ipairs(workspace:GetChildren()) do
			if obj:IsA("Model") and (obj:FindFirstChild("Team") or obj:FindFirstChildOfClass("Humanoid")) then
				table.insert(filterList, obj)
			end
		end
		raycastParams.FilterDescendantsInstances = filterList

		local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

		-- If no ground found within 15 studs, there's open air
		if not raycastResult then
			return true -- Open air detected
		end

		-- If ground is more than 5 studs below, consider it open air (bot should fall)
		-- Increased threshold from 2 to 5 to allow walking up slopes
		local groundDistance = botPosition.Y - raycastResult.Position.Y
		if groundDistance > 5 then
			return true -- Open air (ground is too far below)
		end

		return false -- Ground is close enough (bot is on terrain or a slope)
	end

	RunService.Heartbeat:Connect(function()
		if not bot.Parent or humanoid.Health <= 0 or not rootPart.Parent then
			return
		end

		-- Wait for Humanoid to be ready
		if not humanoidReady then
			return
		end

		-- Check if Humanoid has root part
		if not humanoid.RootPart then
			return
		end

		-- Get bot position (let it move naturally on terrain)
		local botPos = rootPart.Position
		local currentTime = tick()

		-- Check if bot is in spawn protection period (first 5 seconds)
		local timeSinceSpawn = currentTime - spawnTime
		local inSpawnProtection = timeSinceSpawn < SPAWN_PROTECTION_DURATION

		-- CONTINUOUS CHECK: Check for open air every frame and let bot fall if detected
		-- This ensures bots fall immediately when they step over open air
		-- But only if they're truly floating (not just on a slope)

		-- ALWAYS ensure bot is unanchored (unless dead) - this is critical for gravity
		if humanoid.Health > 0 then
			rootPart.Anchored = false
		end

		if checkForOpenAir(botPos) then
			-- There's open air beneath the bot - ensure it can fall with gravity
			rootPart.Anchored = false
			-- Also ensure humanoid physics states are enabled for falling
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
			-- Bot will fall naturally - movement can continue but bot will drop
		end

		-- If in spawn protection, skip all movement commands (but allow gravity/falling)
		if inSpawnProtection then
			return -- Don't process movement, but gravity/falling checks above still run
		end

		if currentTime - lastMoveTime < 0.5 then
			return -- Don't update path every frame (but open air check still runs)
		end
		lastMoveTime = currentTime

		-- Get terrain height at bot's current position
		local terrainHeight = getTerrainHeight(botPos.X, botPos.Z)

		-- Safety check: if bot falls too far below terrain, correct it
		if botPos.Y < terrainHeight - 10 then
			-- Bot fell through terrain - correct position
			local correctedPos = Vector3.new(botPos.X, terrainHeight + 2, botPos.Z)
			rootPart.Position = correctedPos
			botPos = correctedPos
		end

		-- Ensure bot respects gravity: if bot is floating above terrain, let it fall naturally
		-- But allow bots to climb slopes (they may be above terrain when going uphill)
		local heightAboveTerrain = botPos.Y - terrainHeight

		-- CRITICAL: Always ensure bot is unanchored (unless dead) for gravity to work
		if humanoid.Health > 0 then
			rootPart.Anchored = false
		end

		-- If bot is way too high (>30 studs), force it down to prevent infinite floating
		-- Increased threshold from 20 to 30 to allow climbing steeper terrain
		if heightAboveTerrain > 30 then
			-- Bot is way too high - force it to terrain level
			local groundedPos = Vector3.new(botPos.X, terrainHeight + 2, botPos.Z)
			rootPart.Position = groundedPos
			rootPart.Anchored = false -- Ensure bot can fall if needed
			botPos = groundedPos
			print("  ðŸ”½ " .. bot.Name .. " forced to ground (too high): " .. tostring(groundedPos) .. " (was " .. string.format("%.1f", heightAboveTerrain) .. " studs above terrain)")
			return
		end

		-- Additional check: if bot is way too high (like on ceiling), force down immediately
		if botPos.Y > 150 then
			-- Bot is extremely high (likely on ceiling) - force to safe ground level
			local safeGroundY = math.max(terrainHeight + 2, 10) -- At least 10 studs, or terrain + 2
			local groundedPos = Vector3.new(botPos.X, safeGroundY, botPos.Z)
			rootPart.Position = groundedPos
			rootPart.Anchored = false
			botPos = groundedPos
			print("  ðŸš¨ " .. bot.Name .. " was on ceiling (Y=" .. string.format("%.1f", botPos.Y) .. ") - forced to ground: " .. tostring(groundedPos))
			return
		end

		-- Stuck detection: Check if bot has moved significantly in last 2 seconds
		if lastPosition then
			local timeSinceLastCheck = currentTime - lastPositionTime
			local distanceMoved = (botPos - lastPosition).Magnitude

			-- If bot hasn't moved much (< 5 studs) in 2+ seconds, it's stuck
			if timeSinceLastCheck >= 2 and distanceMoved < 5 then
				-- Bot is stuck - make it jump and continue forward instead of turning
				if humanoid and humanoid.Health > 0 then
					humanoid.Jump = true -- Trigger jump
					print("ðŸ”„ " .. bot.Name .. " stuck - jumping to get unstuck (moved " .. string.format("%.1f", distanceMoved) .. " studs in " .. string.format("%.1f", timeSinceLastCheck) .. "s)")
				end
				lastPosition = botPos -- Reset stuck detection
				lastPositionTime = currentTime
			elseif timeSinceLastCheck >= 2 then
				-- Bot moved enough (> 5 studs in 2 seconds) - not stuck
				lastPosition = botPos
				lastPositionTime = currentTime
			end
		else
			-- Initialize position tracking
			lastPosition = botPos
			lastPositionTime = currentTime
		end

		-- Target: enemy spawn position (on terrain)
		if enemySpawnPos then
			-- Find terrain height at enemy spawn location
			local enemyTerrainHeight = getTerrainHeight(enemySpawnPos.X, enemySpawnPos.Z)
			local baseTargetPos = Vector3.new(enemySpawnPos.X, enemyTerrainHeight + 2, enemySpawnPos.Z)

			-- Always go directly towards enemy spawn (no direction offset - bots jump when stuck instead)
			local targetPos = baseTargetPos

			-- Check if bot has reached enemy spawn (within 10 studs)
			local distanceToTarget = (botPos - targetPos).Magnitude
			if distanceToTarget < 10 then
				-- Bot reached enemy spawn - kill it
				-- print("ðŸ’€ " .. bot.Name .. " reached enemy spawn - eliminated!")
				humanoid.Health = 0
				return
			end

			-- Use pathfinding to move towards target
			local path = PathfindingService:CreatePath({
				AgentRadius = 2, -- Width (4 studs / 2)
				AgentHeight = 10, -- Height for double-sized bots (was 5)
				AgentCanJump = true
			})

			local success, errorMessage = pcall(function()
				path:ComputeAsync(botPos, targetPos)
			end)

			if success and path.Status == Enum.PathStatus.Success then
				local waypoints = path:GetWaypoints()
				if #waypoints > 1 then
					-- Move to next waypoint - let pathfinding handle slopes naturally
					local waypointPos = waypoints[2].Position
					-- Get terrain height at waypoint for reference
					local waypointTerrainHeight = getTerrainHeight(waypointPos.X, waypointPos.Z)
					-- Use the waypoint's Y position if it's reasonable (allows climbing)
					-- Only adjust if waypoint is way too high or too low
					local finalWaypointY = waypointPos.Y
					if waypointPos.Y < waypointTerrainHeight - 5 then
						-- Waypoint is too low - use terrain height
						finalWaypointY = waypointTerrainHeight + 2
					elseif waypointPos.Y > waypointTerrainHeight + 35 then
						-- Waypoint is way too high - cap it
						finalWaypointY = waypointTerrainHeight + 30
					end
					-- Otherwise use the waypoint's Y to allow natural slope climbing
					local groundedWaypointPos = Vector3.new(waypointPos.X, finalWaypointY, waypointPos.Z)
					humanoid:MoveTo(groundedWaypointPos)
				else
					-- If only one waypoint, move directly to target (already on terrain)
					humanoid:MoveTo(targetPos)
				end
			else
				-- Fallback: direct movement towards target (already on terrain)
				humanoid:MoveTo(targetPos)
			end
		end
	end)

	-- Bot respawn is handled in the first Died connection above
	-- This second connection is redundant but kept for compatibility

	-- print("Created bot: " .. bot.Name .. " at " .. tostring(groundPos))
	return bot
end

-- Function to find or create a team
local function getOrCreateTeam(teamName, teamColor)
	-- Try to find existing team
	for _, team in ipairs(Teams:GetTeams()) do
		if team.Name == teamName or team.TeamColor == teamColor then
			return team
		end
	end

	-- Create new team if it doesn't exist
	local team = Instance.new("Team")
	team.Name = teamName
	team.TeamColor = teamColor
	team.AutoAssignable = false -- Don't auto-assign players
	team.Parent = Teams
	return team
end

-- Function to update team bot list (stored in a StringValue child)
local function updateTeamBotList(team)
	local botNames = {}

	-- Search for bots by checking their Team StringValue
	for _, obj in ipairs(workspace:GetChildren()) do
		if obj:IsA("Model") then
			local teamValue = obj:FindFirstChild("Team")
			local botNameValue = obj:FindFirstChild("BotName")
			local humanoid = obj:FindFirstChildOfClass("Humanoid")

			-- Check if bot belongs to this team and is alive
			if teamValue and teamValue.Value == team.Name and humanoid and humanoid.Health > 0 then
				-- Use real name if available, otherwise use model name
				local botName = botNameValue and botNameValue.Value or obj.Name
				table.insert(botNames, botName)
			end
		end
	end

	-- Find or create StringValue to store bot list
	local botListValue = team:FindFirstChild("BotList")
	if not botListValue then
		botListValue = Instance.new("StringValue")
		botListValue.Name = "BotList"
		botListValue.Parent = team
	end

	if #botNames > 0 then
		botListValue.Value = table.concat(botNames, ", ")
		print("  ðŸ“‹ Updated " .. team.Name .. " bot list: " .. botListValue.Value)
	else
		botListValue.Value = "No active bots"
		print("  ðŸ“‹ " .. team.Name .. " has no active bots")
	end
end

-- Ensure Red Team and Blue Team exist (matching player teams)
local redTeam = getOrCreateTeam("Red Team", BrickColor.new("Bright red"))
local blueTeam = getOrCreateTeam("Blue Team", BrickColor.new("Bright blue"))

-- Find spawn locations (recursive search to find spawns in folders)
-- print("\nSearching for spawn locations...")

local function findSpawnLocationRecursive(parent, teamName)
	for _, obj in ipairs(parent:GetChildren()) do
		if obj:IsA("SpawnLocation") then
			if teamName == "Red Team" or teamName:find("Red") then
				if obj.Name:find("Red") or obj.TeamColor == BrickColor.new("Bright red") or obj.TeamColor == BrickColor.new("Really red") then
					return obj
				end
			else
				if obj.Name:find("Blue") or obj.TeamColor == BrickColor.new("Bright blue") then
					return obj
				end
			end
		elseif obj:IsA("Folder") or obj:IsA("Model") then
			local found = findSpawnLocationRecursive(obj, teamName)
			if found then return found end
		end
	end
	return nil
end

local redSpawn = workspace:FindFirstChild("RedSpawnLocation")
if not redSpawn then
	redSpawn = findSpawnLocationRecursive(workspace, "Red Team")
	if redSpawn then
		print("  âœ“ Found Red spawn (recursive): " .. redSpawn.Name .. " in " .. (redSpawn.Parent and redSpawn.Parent.Name or "workspace"))
	end
end

local blueSpawn = workspace:FindFirstChild("BlueSpawnLocation")
if not blueSpawn then
	blueSpawn = findSpawnLocationRecursive(workspace, "Blue Team")
	if blueSpawn then
		print("  âœ“ Found Blue spawn (recursive): " .. blueSpawn.Name .. " in " .. (blueSpawn.Parent and blueSpawn.Parent.Name or "workspace"))
	end
end

-- Use default positions if spawn locations not found
local redSpawnPos = redSpawn and redSpawn.Position or Vector3.new(-160, 10, -40)
local blueSpawnPos = blueSpawn and blueSpawn.Position or Vector3.new(923, 10, 208)

-- print("Red spawn position: " .. tostring(redSpawnPos))
-- print("Blue spawn position: " .. tostring(blueSpawnPos))

-- Function to count active bots for a team
local function countActiveBots(teamName)
	local count = 0
	for _, obj in ipairs(workspace:GetChildren()) do
		if obj:IsA("Model") then
			local teamValue = obj:FindFirstChild("Team")
			local humanoid = obj:FindFirstChildOfClass("Humanoid")

			-- Check if bot belongs to this team and is alive
			if teamValue and teamValue.Value == teamName and humanoid and humanoid.Health > 0 then
				count = count + 1
			end
		end
	end
	return count
end

-- Function to adjust spawn locations to terrain (called when player selects team)
-- Preserves relative X/Z positions (relative to baseplate) and only adjusts Y
local function adjustSpawnLocationsToTerrain()
	-- Recursive function to find spawn locations
	local function findSpawnLocationsRecursive(parent, results)
		for _, obj in ipairs(parent:GetChildren()) do
			if obj:IsA("SpawnLocation") then
				table.insert(results, obj)
			elseif obj:IsA("Folder") or obj:IsA("Model") then
				findSpawnLocationsRecursive(obj, results)
			end
		end
	end

	local spawnLocations = {}
	findSpawnLocationsRecursive(workspace, spawnLocations)

	if #spawnLocations == 0 then
		print("  âš  No spawn locations found to adjust")
		return
	end

	print("  ðŸ“ Adjusting " .. #spawnLocations .. " spawn location(s) to terrain (preserving relative positions)...")

	-- Find baseplate for relative positioning
	local baseplate = workspace:FindFirstChild("Baseplate")
	local baseplatePos = nil
	local baseplateTopY = nil
	if baseplate then
		baseplatePos = baseplate.Position
		baseplateTopY = baseplate.Position.Y + (baseplate.Size.Y / 2)
	end

	-- Store relative positions (relative to baseplate center) before adjusting
	local spawnRelativePositions = {}
	for _, spawnLoc in ipairs(spawnLocations) do
		if baseplatePos then
			local relativeX = spawnLoc.Position.X - baseplatePos.X
			local relativeZ = spawnLoc.Position.Z - baseplatePos.Z
			spawnRelativePositions[spawnLoc] = {
				relativeX = relativeX,
				relativeZ = relativeZ
			}
		else
			-- Fallback: store current position if no baseplate
			spawnRelativePositions[spawnLoc] = {
				relativeX = spawnLoc.Position.X,
				relativeZ = spawnLoc.Position.Z
			}
		end
	end

	-- Helper function to find terrain height (filtering out walls/ceiling)
	local function findTerrainHeightForSpawn(x, z)
		local rayOrigin = Vector3.new(x, 500, z)
		local rayDirection = Vector3.new(0, -1000, 0)
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

		-- Filter out walls, ceiling, and other non-terrain parts
		local filterList = {}
		local wallsFolder = workspace:FindFirstChild("Walls")
		if wallsFolder then
			for _, wall in ipairs(wallsFolder:GetChildren()) do
				if wall:IsA("BasePart") then
					table.insert(filterList, wall)
				end
			end
		end
		-- Also filter out ZoneWalls
		local zonePartsFolder = workspace:FindFirstChild("ZoneParts")
		if zonePartsFolder then
			for _, part in ipairs(zonePartsFolder:GetChildren()) do
				if part:IsA("BasePart") and part.Name:find("Wall") then
					table.insert(filterList, part)
				end
			end
		end
		-- Filter out all bots
		for _, obj in ipairs(workspace:GetChildren()) do
			if obj:IsA("Model") and (obj:FindFirstChild("Team") or obj:FindFirstChildOfClass("Humanoid")) then
				table.insert(filterList, obj)
			end
		end

		raycastParams.FilterDescendantsInstances = filterList
		local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

		-- Only accept terrain that's in a reasonable range (not ceiling, max Y=150)
		if raycastResult and raycastResult.Position.Y > -50 and raycastResult.Position.Y < 150 then
			-- Check if it's actually terrain (not a wall/ceiling)
			local hitPart = raycastResult.Instance
			if hitPart and (hitPart.Name == "Terrain" or hitPart:IsDescendantOf(workspace.Terrain)) then
				return raycastResult.Position.Y
			elseif hitPart and not hitPart.Name:find("Wall") and not hitPart.Name:find("Roof") and not hitPart.Name:find("Ceiling") then
				-- It's probably terrain or a part, accept it if it's in reasonable range
				return raycastResult.Position.Y
			end
		end

		-- Fallback to baseplate
		if baseplateTopY then
			return baseplateTopY + 10 -- Baseplate top + 10 studs
		end
		return 10 -- Final fallback
	end

	-- Restore relative positions and adjust Y to terrain height
	for _, spawnLoc in ipairs(spawnLocations) do
		-- Skip DefaultSpawnLocation - don't move it
		if spawnLoc.Name == "DefaultSpawnLocation" then
			print("    â­ Skipping DefaultSpawnLocation (neutral spawn - not adjusting)")
			-- Skip to next iteration (Roblox Lua doesn't support goto)
		else
			local relativePos = spawnRelativePositions[spawnLoc]
			if not relativePos then
				-- Fallback: use current position
				relativePos = {
					relativeX = spawnLoc.Position.X - (baseplatePos and baseplatePos.X or 0),
					relativeZ = spawnLoc.Position.Z - (baseplatePos and baseplatePos.Z or 0)
				}
			end

			-- Restore relative X/Z position
			local spawnX, spawnZ
			if baseplatePos then
				spawnX = baseplatePos.X + relativePos.relativeX
				spawnZ = baseplatePos.Z + relativePos.relativeZ
			else
				-- Fallback: use stored absolute position
				spawnX = relativePos.relativeX
				spawnZ = relativePos.relativeZ
			end

			-- Find terrain height at this relative position
			local terrainHeight = findTerrainHeightForSpawn(spawnX, spawnZ)

			-- Position spawn 10 studs above terrain
			local targetY = terrainHeight + 10

			-- Set spawn properties
			spawnLoc.Anchored = true
			spawnLoc.CanCollide = false

			-- Update position (preserve relative X/Z, adjust Y)
			spawnLoc.CFrame = CFrame.new(spawnX, targetY, spawnZ)

			print("    âœ“ Adjusted " .. spawnLoc.Name .. " to Y = " .. string.format("%.2f", targetY) .. " (relative X: " .. string.format("%.2f", relativePos.relativeX) .. ", Z: " .. string.format("%.2f", relativePos.relativeZ) .. ", terrain: " .. string.format("%.2f", terrainHeight) .. ")")
		end
	end

	print("  âœ“ Spawn location adjustment complete!")
end

-- Maximum bots per team
local MAX_BOTS_PER_TEAM = 5

-- print("\nðŸ“Š Bot limit: Maximum " .. MAX_BOTS_PER_TEAM .. " active bots per team")

-- Function to spawn one red bot (only if under limit)
local function spawnRedBot()
	-- Check if we're at the limit
	local activeCount = countActiveBots("Red Team")
	if activeCount >= MAX_BOTS_PER_TEAM then
		-- print("  â¸ Red team at limit (" .. activeCount .. "/" .. MAX_BOTS_PER_TEAM .. ") - skipping spawn")
		return nil
	end

	local spawnOffset = Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
	local bot = createSimpleBot(redSpawnPos + spawnOffset, Color3.new(1, 0, 0), "Red Team", blueSpawnPos)
	if bot then
		-- print("  âœ“ Spawned: " .. bot.Name .. " (Red team: " .. (activeCount + 1) .. "/" .. MAX_BOTS_PER_TEAM .. ", moving towards BLUE)")
		-- Wait a frame to ensure bot is fully in workspace
		task.wait(0.1)
		-- Update team bot list
		updateTeamBotList(redTeam)
		-- Track bot removal to update team list
		bot:GetPropertyChangedSignal("Parent"):Connect(function()
			if not bot.Parent then
				task.wait(0.1)
				updateTeamBotList(redTeam)
			end
		end)
		return bot
	else
		-- print("  âš  Failed to spawn Red bot")
		return nil
	end
end

-- Function to spawn one blue bot (only if under limit)
local function spawnBlueBot()
	-- Check if we're at the limit
	local activeCount = countActiveBots("Blue Team")
	if activeCount >= MAX_BOTS_PER_TEAM then
		-- print("  â¸ Blue team at limit (" .. activeCount .. "/" .. MAX_BOTS_PER_TEAM .. ") - skipping spawn")
		return nil
	end

	local spawnOffset = Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
	local bot = createSimpleBot(blueSpawnPos + spawnOffset, Color3.new(0, 0, 1), "Blue Team", redSpawnPos)
	if bot then
		-- print("  âœ“ Spawned: " .. bot.Name .. " (Blue team: " .. (activeCount + 1) .. "/" .. MAX_BOTS_PER_TEAM .. ", moving towards RED)")
		-- Wait a frame to ensure bot is fully in workspace
		task.wait(0.1)
		-- Update team bot list
		updateTeamBotList(blueTeam)
		-- Track bot removal to update team list
		bot:GetPropertyChangedSignal("Parent"):Connect(function()
			if not bot.Parent then
				task.wait(0.1)
				updateTeamBotList(blueTeam)
			end
		end)
		return bot
	else
		-- print("  âš  Failed to spawn Blue bot")
		return nil
	end
end

-- CLEANUP: Remove all existing bots at the start
-- print("\nðŸ§¹ Cleaning up existing bots...")
local cleanupCount = 0
for _, obj in ipairs(workspace:GetChildren()) do
	-- Check if it's a bot by looking for Team StringValue
	if obj:IsA("Model") then
		local teamValue = obj:FindFirstChild("Team")
		if teamValue and (teamValue.Value == "Red Team" or teamValue.Value == "Blue Team") then
			obj:Destroy()
			cleanupCount = cleanupCount + 1
		end
	end
end
-- print("  âœ“ Removed " .. cleanupCount .. " existing bot(s)")

-- CLEANUP: Remove orphaned parts floating in the sky (artifacts from bot creation)
local function cleanupOrphanedParts()
	local orphanedCount = 0
	for _, obj in ipairs(workspace:GetDescendants()) do
		local shouldSkip = false

		-- Check for parts that are floating high in the sky (Y > 100) and not part of a valid model
		if obj:IsA("BasePart") and obj.Position.Y > 100 then
			-- Skip if it's part of a valid bot model
			local model = obj:FindFirstAncestorOfClass("Model")
			if model then
				local teamValue = model:FindFirstChild("Team")
				if teamValue and (teamValue.Value == "Red Team" or teamValue.Value == "Blue Team") then
					-- It's part of a valid bot, skip
					shouldSkip = true
				end
			end

			-- Skip if it's a wall, ceiling, or other important part
			if not shouldSkip then
				if obj.Name:find("Wall") or obj.Name:find("Roof") or obj.Name:find("Ceiling") or 
					obj:IsDescendantOf(workspace:FindFirstChild("Walls")) or
					obj:IsDescendantOf(workspace:FindFirstChild("ZoneParts")) then
					shouldSkip = true
				end
			end

			-- Skip if it's the baseplate or terrain
			if not shouldSkip then
				if obj.Name == "Baseplate" or obj:IsDescendantOf(workspace.Terrain) then
					shouldSkip = true
				end
			end

			-- Skip if it's a player character part
			if not shouldSkip then
				local character = obj:FindFirstAncestorOfClass("Model")
				if character and Players:GetPlayerFromCharacter(character) then
					shouldSkip = true
				end
			end

			-- This is an orphaned part floating in the sky - remove it
			if not shouldSkip then
				obj:Destroy()
				orphanedCount = orphanedCount + 1
			end
		end

		-- Also check for orphaned BillboardGuis (health bars) that aren't attached to anything
		if obj:IsA("BillboardGui") and obj.Name == "HealthBar" then
			local adornee = obj.Adornee
			if not adornee or not adornee.Parent then
				-- Health bar is orphaned - remove it
				obj:Destroy()
				orphanedCount = orphanedCount + 1
			end
		end

		-- Check for orphaned parts that are small cubes (likely artifacts)
		if obj:IsA("BasePart") and obj.Position.Y > 100 and obj.Size.Magnitude < 5 then
			local model = obj:FindFirstAncestorOfClass("Model")
			if not model or (not model:FindFirstChild("Team") and not Players:GetPlayerFromCharacter(model)) then
				-- Small orphaned part in sky - likely an artifact
				if not obj.Name:find("Wall") and not obj:IsDescendantOf(workspace:FindFirstChild("Walls")) then
					obj:Destroy()
					orphanedCount = orphanedCount + 1
				end
			end
		end
	end
	if orphanedCount > 0 then
		print("  ðŸ§¹ Cleaned up " .. orphanedCount .. " orphaned part(s) from sky")
	end
end

-- Run cleanup periodically (every 30 seconds)
spawn(function()
	while true do
		task.wait(30)
		cleanupOrphanedParts()
	end
end)

-- Run initial cleanup after a short delay
task.wait(2)
cleanupOrphanedParts()

-- Listen for players joining teams and adjust spawn locations
local spawnLocationsAdjusted = false
Players.PlayerAdded:Connect(function(player)
	-- When a player's team changes, adjust spawn locations if not already done
	player:GetPropertyChangedSignal("Team"):Connect(function()
		if player.Team and not spawnLocationsAdjusted then
			-- First player to select a team - adjust spawn locations
			spawnLocationsAdjusted = true
			print("\nðŸŽ¯ First player selected team - adjusting spawn locations to terrain...")
			adjustSpawnLocationsToTerrain()

			-- Update spawn positions for bot spawning
			local function findSpawnRecursive(parent, teamName)
				for _, obj in ipairs(parent:GetChildren()) do
					if obj:IsA("SpawnLocation") then
						if teamName == "Red Team" then
							if obj.Name:find("Red") or obj.TeamColor == BrickColor.new("Bright red") then
								return obj
							end
						else
							if obj.Name:find("Blue") or obj.TeamColor == BrickColor.new("Bright blue") then
								return obj
							end
						end
					elseif obj:IsA("Folder") or obj:IsA("Model") then
						local found = findSpawnRecursive(obj, teamName)
						if found then return found end
					end
				end
				return nil
			end

			-- Update cached spawn positions
			local newRedSpawn = findSpawnRecursive(workspace, "Red Team")
			if newRedSpawn then
				redSpawn = newRedSpawn
				redSpawnPos = newRedSpawn.Position
				print("  âœ“ Updated Red spawn position: " .. tostring(redSpawnPos))
			end

			local newBlueSpawn = findSpawnRecursive(workspace, "Blue Team")
			if newBlueSpawn then
				blueSpawn = newBlueSpawn
				blueSpawnPos = newBlueSpawn.Position
				print("  âœ“ Updated Blue spawn position: " .. tostring(blueSpawnPos))
			end
		end
	end)
end)

-- Also check existing players
for _, player in ipairs(Players:GetPlayers()) do
	if player.Team and not spawnLocationsAdjusted then
		spawnLocationsAdjusted = true
		print("\nðŸŽ¯ Player already on team - adjusting spawn locations to terrain...")
		adjustSpawnLocationsToTerrain()
		break
	end
end

-- Initialize team bot lists
updateTeamBotList(redTeam)
updateTeamBotList(blueTeam)

-- Periodically update team bot lists (every 5 seconds) to catch any missed updates
spawn(function()
	while true do
		task.wait(5)
		updateTeamBotList(redTeam)
		updateTeamBotList(blueTeam)
	end
end)

-- Create a flag in workspace to control spawning
local spawnFlag = workspace:FindFirstChild("BotSpawningEnabled")
if not spawnFlag then
	spawnFlag = Instance.new("BoolValue")
	spawnFlag.Name = "BotSpawningEnabled"
	spawnFlag.Value = true
	spawnFlag.Parent = workspace
end
spawnFlag.Value = true -- Enable spawning

-- Initial spawn: DISABLED - only periodic spawning every 10 seconds
-- print("\nInitial spawn disabled - bots will spawn every 10 seconds...")

-- Continuous spawning: one bot per team every 10 seconds
-- Scripts automatically stop when exiting test mode, so no need to check RunService:IsRunning()
spawn(function()
	local loopId = math.random(10000, 99999) -- Unique ID for this loop
	-- print("ðŸ”„ Spawn loop #" .. loopId .. " started")

	while true do
		-- Check if spawning is disabled (flag missing or false = stop)
		local flag = workspace:FindFirstChild("BotSpawningEnabled")
		if not flag then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag not found (was destroyed)")
			break
		end
		if not flag.Value then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag is false")
			break
		end

		-- Check if game is still running (workspace exists)
		if not workspace or not workspace.Parent then
			-- print("ðŸ›‘ Game stopped - bot spawning halted")
			break
		end

		-- Wait 10 seconds, but check flag every 0.5 seconds
		local waitTime = 0
		while waitTime < 10 do
			task.wait(0.5) -- Check every 0.5 seconds
			waitTime = waitTime + 0.5

			-- Check flag during wait
			local flagCheck = workspace:FindFirstChild("BotSpawningEnabled")
			if not flagCheck then
				-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped during wait - flag destroyed")
				return -- Exit the function
			end
			if not flagCheck.Value then
				-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped during wait - flag is false")
				return -- Exit the function
			end

			-- Check if game is still running
			if not workspace or not workspace.Parent then
				return
			end
		end

		-- Final check before spawning
		local finalFlagCheck = workspace:FindFirstChild("BotSpawningEnabled")
		if not finalFlagCheck then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag destroyed before spawn")
			break
		end
		if not finalFlagCheck.Value then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag is false before spawn")
			break
		end

		if not workspace or not workspace.Parent then
			break
		end

		-- print("\nâ° Spawning new bots (every 10 seconds)...")

		-- Check flag before spawning red bot
		local redFlagCheck = workspace:FindFirstChild("BotSpawningEnabled")
		if not redFlagCheck then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag destroyed before Red bot")
			break
		end
		if redFlagCheck.Value then
			spawnRedBot()
		else
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag is false before Red bot")
			break
		end

		task.wait(0.5) -- Small delay between teams

		-- Check flag before spawning blue bot
		local blueFlagCheck = workspace:FindFirstChild("BotSpawningEnabled")
		if not blueFlagCheck then
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag destroyed before Blue bot")
			break
		end
		if blueFlagCheck.Value then
			spawnBlueBot()
		else
			-- print("ðŸ›‘ Spawn loop #" .. loopId .. " stopped - flag is false before Blue bot")
			break
		end
	end
end)

-- print("\nâœ… Bot spawner is running!")
-- print("ðŸ’¡ To stop spawning, set workspace.BotSpawningEnabled.Value = false")
-- print("   Or run StopBotSpawning_CommandBar.lua")

